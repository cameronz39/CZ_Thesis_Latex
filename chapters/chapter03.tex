\chapter{Methodology}\label{chap:methodology}

\section{Theoretical Framework}\label{sec:framework}

This section introduces the mathematical formulation of key balancing methods found in literature. It also provides a common set of definitions and conventions which are crucial when developing the corresponding simulation and code for the onboard computer.

\subsection{Problem Definition}\label{sec:mbs_problem}

\begin{figure}[ht]
    \centering
    \input{figures/mbs_problem.tikz}
    \caption{The mass balancing problem for air bearing based spacecraft dynamics simulators}
    \label{fig:mbs_problem}
\end{figure}

The problem definition here is based on work by Kim and Argawal~\cite{kim_automatic_2009}. \Cref{fig:mbs_problem} defines the geometry of the problem in a general case. $O$ represents the common origin of the inertial frame $\mathcal{N}$ and the body-fixed principle frame of the simulator $\mathcal{B}$. $O$ is chosen to be the center of rotation. If frictionless rotation is assumed, then the simulator follows Euler's rotational equations of motion with gravity acting as a torque~\cite{healy_mass_2006}. The governing equation is 
\begin{equation}
    \bm{J}\,\dot{\bm{\omega}} + \bm{\omega}^{\times}\,\bm{J}\bm{\omega} = \bm{T}_g
\end{equation}
where $\bm{J}$ is the inertia of the simulator about $O$, $\bm{\omega}$ is the angular velocity of the simulator, and $\bm{T}_g$ is the torque due to gravity. $\dot{\bm{v}}$ represents the time derivative of some vector $\bm{v}$, and $\bm{v}^{\times}$ represents the skew-symmetric cross-product matrix of $\bm{v}$. In general it is more convenient to expand $\bm{T}_g$ which leads to
\begin{equation}\label{equation:starting_eom}
    \bm{J}\,\dot{\bm{\omega}} + \bm{\omega}^{\times}\,\bm{J}\bm{\omega} = m_s\bm{r}^{\times}\bm{g}
\end{equation}
where $m_s$ is the total mass of the simulator, $\bm{r}$ is the center of mass relative to $O$, and the $\bm{g}$ is the acceleration due to gravity.

\Cref{fig:mbs_problem} also shows the introduces the three sliding masses used to balance the platform. Although in general there may be as many as $n$ sliding masses. Each mass $m_i$ has one translational degree of freedom along $\bm{u}_i$, and $\bm{\rho}_i$ represents the position of the $i$-th mass in its homed position. Since in practice each mass can only travel some limited distance along $\bm{u}_i$, the homed position of a mass is typically chosen as the center of this range of positions. The position relative to $O$ of any mass $\bm{R}_i$ can be obtained with 
\begin{equation}\label{equation:sliding masses}
    \bm{R}_i = \bm{\rho}_i + d_i\bm{u_i}
\end{equation}
where $d_i$ is the distance mass $m_i$ has travelled along $u_i$ relative to its zeroed position. More generally, $\Delta\,d_i$ is defined as the change in position a mass from any arbitrary starting position.

Additionally, $\bm{R}_i$ may change with time, say through linear actuators. It is assumed the linear actuators have some form of absolute positioning, or that they can command the masses to their homed positions in a repeatable way. Let $\bm{J}_0$ be the total inertia of the simulator with the masses in their homed positions. The inertia as a function of time is then 
\begin{equation}
    \bm{J}(t)=\bm{J}_0-\sum_{i=0}^{n}(m_i\bm{R}_i^{\times}(t)\bm{R}_i^{\times}(t)-\bm{\rho}_i^{\times}\bm  {\rho}_i^{\times})
\end{equation}
The sliding mass will also introduce angular momentum into the system, which can be calculated using 
\begin{equation}
    \bm{h}_m =\sum_{n}^{i=1}\bm{R}_i^{\times}m_i\dot{\bm{R}}_i^{\times}
\end{equation}
In practical mass balancing applications however, the mass of each block is very small relative to the overall mass of the simulator. If a reasonable attempt is made to balance the simulator manually beforehand, then the masses will also move slowly and over short distances. This allows the following simplifications to be made
\begin{equation}
\bm{J}(t) \approx \bm{J}_0 \Longrightarrow \dot{\bm{J}}=\bm{0}
\end{equation}
\begin{equation}\label{equation:h_m_eq_0}
\dot{\bm{R}}_i \approx \bm{0} \Longrightarrow \bm{h}_m=\bm{0}
\end{equation}
The goal of these definitions is to obtain the dynamics equations relating how changing the positions of each mass effects the center of mass of the total system. These parameters are first assembled into matrices as follows
\begin{equation}
    \bm{M}=\mathrm{diag}(\frac{m_1}{m_s}, \cdots  ,\frac{m_n}{m_s}) \in \mathbb{R}^{n \times n}
\end{equation}
\begin{equation}
    \bm{U}=
    \begin{bmatrix}
        \bm{u}_1, & \cdots & ,\bm{u}_n
    \end{bmatrix}
    \in \mathbb{R}^{3 \times n}
\end{equation}
\begin{equation}
    \Delta\bm{d}=
    \begin{bmatrix}
        \Delta\,d_1, & \cdots & ,\Delta\,d_n 
    \end{bmatrix}^T
    \in \mathbb{R}^{n}
\end{equation}
Using these definitions, writing $\Delta\bm{r}$ as a function of $\Delta\bm{d}$ becomes a simple matrix multiplication
\begin{equation}
    \Delta\bm{r} = \bm{U}\bm{M}\Delta\bm{d}
\end{equation}
This means the value of $\bm{r}$ at any point can be written as $\bm{r}=\bm{r}_0+\Delta\bm{r}$, where $\bm{r}_0$ is the center of mass with the masses in their homed positions. An equally important relation is writing $\Delta\bm{d}$ as a function of $\Delta\bm{r}$. For the case $n = 3$ with linearly independent values of $\bm{u}_i$, the unique solution is given by
\begin{equation}\label{equation:delta_d_sol}
    \Delta\bm{d} = (\bm{U}\bm{M})^{-1}\Delta\bm{r}
\end{equation}
If $n>3$, a solution that minimizes the mass moved can be found using a pseudoinverse approach
\begin{equation}\label{equation:delta_d_pseudo_sol}
    \Delta\bm{d} = (\bm{U}\bm{M})^{\dagger }\Delta\bm{r}
\end{equation}
where $(\bm{U}\bm{M})^{\dagger}$ represents the Moore-Penrose pseudoinverse of $\bm{UM}$.

There are two main approaches to solving the mass balancing problem. The first is to hold the mass positions constant and obtain an estimate of the value of $\bm{r}$, denoted as $\hat{\bm{r}}$. The required change in positions of the sliding masses are then applied all at once. The exact values are calculated from \Cref{equation:delta_d_sol} or \Cref{equation:delta_d_pseudo_sol}, substituting $-\hat{\bm{r}}$ for $\Delta\bm{r}$. This class of approaches is referred to passive balancing~\cite{da_silva_review_2021}.

The second main approach is to find a feedback control law that drives the effect of the $m_s\bm{r}^{\times}\bm{g}$ term in \Cref{equation:starting_eom} to zero. In traditional spacecraft ADCS, the torques required for a feedback controller are generated using momentum exchange devices, but here, there is the additional option to use $\Delta\bm{d}$ as a control input. Referring to \Cref{equation:starting_eom}, the dynamics of the system are influenced by the value of $\bm{r}^{\times}$, whose value can be controlled by $\Delta\bm{d}$ using \Cref{equation:delta_d_sol} or \Cref{equation:delta_d_pseudo_sol}. This class of approaches is referred to as active balancing~\cite{da_silva_review_2021}.

\subsubsection{Verification Methods}

Once any balancing procedure has been performed, it is important to verify the results through an external verification method. A direct approach is to measure the torque due to gravity as the simulator freely tumbles. The simulator is first manually positioned into a non-upright orientation and then released. The body rates are recorded and the average torque is computed using
\begin{equation}
    T_{g,avg} = \text{mean}||\bm{J}\dot{\bm{\omega}} + \bm{\omega}^{\times}\bm{J}\bm{\omega}||
\end{equation}
This method requires the numerical derivative of the measured body rates to compute $\dot{\bm{\omega}}$, which may be challenging depending on the noise characteristics of the IMU.

Another verification method that does not require numerical derivatives is observing the total mechanical energy of the simulator while it undergoes this same tumbling motion. The mechanical energy is given by
\begin{equation}
    E_{mech} = \frac{1}{2}\bm{\omega}^T\bm{J}\bm{\omega} + mgh
\end{equation}
where $h$ is the vertical coordinate of $\bm{r}$ in the inertial frame~\cite{silva_filtering_2018}. If the simulator is balanced, $h$ will remain relatively constant throughout the pendulum motion, and the kinetic energy term $\frac{1}{2}\bm{\omega}^T\bm{J}\bm{\omega}$ will also remain relatively constant due to the conservation of energy. As the balance of the simulator improves, the kinetic energy will oscillate with smaller amplitudes.

\subsection{Attitude Representation and Kinematics}

Many balancing algorithms require knowledge of the simulator's attitude in real-time. In this work, quaternions are used exclusively in kinematics as a singularity-free representation of the simulator's attitude \cite{de2012spacecraft}. Here, the quaternion $\bm{q}$ is defined as a frame rotation from the body frame to the inertial frame, with the real part $\eta$ of the quaternion first ($\eta$ = $q_0$). $\bm{q}$ is then a four component vector written as 
\begin{equation}
    \bm{q} = \begin{bmatrix}
        \eta & \bm{\epsilon}
    \end{bmatrix}^T
    = \begin{bmatrix}
        q_0 & q_1 & q_2 & q_3
    \end{bmatrix}^T
\end{equation}
The simulator quaternion at any point may be directly converted into a direction cosine matrix using the following
\begin{equation}\label{equation:C_from_q}
    \bm{C}_{\mathcal{N}\leftarrow\mathcal{B}}(\bm{q})=(\eta^2-\bm{\epsilon}^T\bm{\epsilon})\mathbb{1}
    +
    2\bm{\epsilon}\bm{\epsilon}^T
    +
    2\eta\bm{\epsilon}^{\times}
\end{equation}
where $\bm{C}_{\mathcal{N}\leftarrow\mathcal{B}}$ again represents the frame rotation from $\mathcal{B}$ to $\mathcal{N}$. This means $\bm{C}_{\mathcal{N}\leftarrow\mathcal{B}}$ satisfies the following properties
\begin{equation}
    \bm{v}^{\mathcal{N}} = 
    \bm{C}_{\mathcal{N}\leftarrow\mathcal{B}}\bm{v}^{\mathcal{B}}
\end{equation}
\begin{equation}
    \bm{v}^{\mathcal{B}} = 
    \bm{C}_{\mathcal{N}\leftarrow\mathcal{B}}^T\bm{v}^{\mathcal{N}}
    =\bm{C}_{\mathcal{B}\leftarrow\mathcal{N}}\bm{v}^{\mathcal{N}}
\end{equation}
where $\bm{v}^{\mathcal{B}}$ are the components of some physical vector expressed in $\mathcal{B}$ and $\bm{v}^{\mathcal{N}}$ are the components of the same vector expressed in $\mathcal{N}$. 

The quaternion propagates forward through time as a function of the simulator's body rate $\bm{\omega}$ according to the following differential equation
\begin{equation}\label{equation:quat_kinematics}
    \dot{\bm{q}} = \frac{1}{2}
\begin{bmatrix}
0 & -\omega_x & -\omega_y & -\omega_z \\
\omega_x & 0 & \omega_z & -\omega_y \\
\omega_y & -\omega_z & 0 & \omega_x \\
\omega_z & \omega_y & -\omega_x & 0
\end{bmatrix}
\bm{q}
\end{equation}
This relationship forms the base of the propagatation step in the Kalman filter implemented later. 

When plotting and interpreting results, the quaternion representation is often converted to Euler angles $(\phi,\theta,\psi)$, or roll, pitch, yaw respectively. This conversion is performed using
\begin{equation}
\begin{split}
\psi &= \text{arctan2}\!\left(2(q_0 q_3 + q_1 q_2),\, 1 - 2(q_2^2 + q_3^2)\right), \\[4pt]
\phi &= \text{arctan2}\!\left(2(q_0 q_1 + q_2 q_3),\, 1 - 2(q_1^2 + q_2^2)\right), \\[4pt]
\theta &= \arcsin\!\left(2(q_0 q_2 - q_3 q_1)\right)
\end{split}
\end{equation}
where $\text{arctan2}$ is the 2-argument arctangent function~\cite{bernardes2022quaternion}. This represents the attitude as a series of intrinsic rotations about the body axes using a $(3,2,1)$ rotation sequence. Although Euler angles are used in post-processing and visualization, all onboard computations are performed using quaternions to avoid singularities.

\subsection{Least-Squares/Batch Estimation Algorithms}\label{sec:LSR}

Batch estimation algorithms are a subset of passive balancing methods that use momentum exchange devices to excite the simulator and record the resulting body rate and attitude data. The equations of motion are manipulated to help obtain multiple estimates of $\bm{r}$, and a single, final estimate of $\bm{r}$ is calculated using least-squares error methods. Many variations of batch estimation algorithms exist \cite{kim_automatic_2009} \cite{chesi_automatic_2014} \cite{silva_applied_2010}, but they all start with same principle of separating the constant mass properties from the dynamic states in the equations of motion. This separation is done by defining the following variables:
\begin{equation}
    \bm{\Omega} =
        \begin{bmatrix}
            \omega_x & 0 & 0 & \omega_y & \omega_z & 0 \\
            0 & \omega_y & 0 & \omega_x & 0 & \omega_z \\
            0 & 0 & \omega_z & 0 & \omega_x & \omega_y
        \end{bmatrix}
\end{equation}
\begin{equation}
    \bm{x} = \begin{bmatrix}
        J_{xx} & J_{yy} & J_{zz} & J_{xy} & J_{xz} & J_{yz} & m_s\,r_x & m_s\,r_y & m_s\,r_z
    \end{bmatrix}^T
\end{equation}
Here, $\bm{\Omega}$ is formulated to simplfy the resulting algebra, while $\bm{x}$ is formulated to fully encode all of the simulator's mass properties.

Using these values, the original equations of motion in \Cref{equation:starting_eom} can be exactly rewritten as 
\begin{equation}\label{equation:no_MEDs}
    \begin{bmatrix}
        \dot{\bm{\Omega}}+\bm{\omega}^{\times}\bm{\Omega} & \bm{g}^{\times}
    \end{bmatrix}\bm{x}
    =\bm{0}
\end{equation}
with the goal being to eventually solve for $\bm{x}$. To avoid nullspace solutions (which give physically invalid mass properties), additional terms must be introduced to the right hand side. This is done through the use of momentum exchange devices which changes \Cref{equation:no_MEDs} into 
\begin{equation}\label{equation:with_MEDs}
    \begin{bmatrix}
    \dot{\bm{\Omega}}+\bm{\omega}^{\times}\bm{\Omega} & \bm{g}^{\times}
    \end{bmatrix}\bm{x}
    =-\dot{\bm{h}}_c - \bm{\omega}^{\times}\bm{h_c}
\end{equation}

where $\bm{h}_c$ represents the total angular momentum of the MEDs. Additionally, to avoid taking the numerical derivative of the noisy signal $\bm{\omega}$ (which will come from gyroscopes), both sides of \Cref{equation:with_MEDs} are integrated with respect to time which results in 
\begin{equation}\label{equation:LSM_no_k}
    \begin{bmatrix}
    \int_{t_0}^{t}\dot{\bm{\Omega}}+\bm{\omega}^{\times}\bm{\Omega}\,dt & \int_{t_0}^{t}\bm{g}^{\times}\,dt
    \end{bmatrix}\bm{x}
    =-{\bm{h_c}} - \int_{t_0}^{t}\bm{\omega}^{\times}\bm{h_c}\,dt
\end{equation}

For each timestep $k$ where a measurement is taken, a new $\bm{A}$ and $\bm{T}$ matrix are created using
\begin{equation}
    \bm{A}_k=\begin{bmatrix}
    \int_{t_0}^{t_k}\dot{\bm{\Omega}}+\bm{\omega}^{\times}\bm{\Omega}\,dt & \int_{t_0}^{t_k}\bm{g}^{\times}\,dt
    \end{bmatrix}
\end{equation}
\begin{equation}
    \bm{T}_k=-{\bm{h_c}} - \int_{t_0}^{t}\bm{\omega}^{\times}\bm{h_c}\,dt
\end{equation}
which allows \Cref{equation:LSM_no_k} to be rewritten as 
\begin{equation}\label{equation:LSM_with_k}
    \bm{A}_k\bm{x}=\bm{T}_k
\end{equation}

Since all measurements are corrupted by noise, there will not be any single value of $\bm{x}$ that will satisfy \Cref{equation:LSM_with_k} for all $k$. Instead, the key idea with least squares estimation methods is to find a value of $\bm{x}$ that minimizes the error in \Cref{equation:LSM_with_k} across all $k$. The most common way to achieve this is to create augmented versions of $\bm{A}$ and $\bm{T}$ as
\begin{equation}\label{equation:A_bar}
    \bar{\bm{A}}=\begin{bmatrix}
    \bm{A}_0 \\ \bm{A}_1 \\ \vdots \\ \bm{A}_n
    \end{bmatrix}\in\mathbb{R}^{3(n+1)\times 9},\qquad
    \bar{\bm{T}}=\begin{bmatrix}
    \bm{T}_0 \\ \bm{T}_1 \\ \vdots \\ \bm{T}_n
    \end{bmatrix}\in\mathbb{R}^{3(n+1)\times 1}.
\end{equation}

where $n+1$ is the total number of measurements. $\bm{x}$ is finally computed using 
\begin{equation}
    \bm{x}=\bar{\bm{A}}^{\dagger}\bar{\bm{T}}
\end{equation}

Alternatively, if the inertia of the simulator is already well-known, then $\bm{x}$ can be reformulated as
\begin{equation}
    \bm{x} = \begin{bmatrix}
        m_s\,r_x & m_s\,r_y & m_s\,r_z
    \end{bmatrix}^T
\end{equation} 
which rearranges $\bm{A}_k$ and $\bm{T}_k$ into

\begin{equation}
    \bm{A}_k=
    \int_{t_0}^{t_k}\bm{g}^{\times}\,dt
\end{equation}

\begin{equation}
    \bm{T}_k=-{\bm{h_c}} - \int_{t_0}^{t_k}\bm{\omega}^{\times}\bm{h_c}\,dt
    - \biggl(
    \int_{t_0}^{t_k}\dot{\bm{\Omega}} + \bm{\omega}^{\times}\bm{\Omega}\,dt
    \biggl)
    \hat{\bm{J}}
\end{equation}
where $\hat{\bm{J}}= [\hat{J}_{xx}\ \hat{J}_{yy}\ \hat{J}_{zz}\ \hat{J}_{xy}\ \hat{J}_{xz}\ \hat{J}_{yz}]^T$ is the already known estimate of the simulator's inertia. The steps to solve for $\bm{x}$ then proceed identically starting from \Cref{equation:A_bar}

The offline batch estimation method requires that multiple tests are run, adjusting the sliding masses after each run using \Cref{equation:delta_d_sol} or \Cref{equation:delta_d_pseudo_sol}. Assuming actuators like reaction wheels are available, this method's main advantage is its ease of implementation. By completing all the estimation and data processing offline, no custom software needs to be written for the simulator's onboard computer. In fact, exciting the system using this method does not require the simulator to have a working feedback controller, allowing this method to be adopted early in the design of a simulator. Researchers have demonstrated success using simple open loop control to ensure that the body rates of the simulator follow a sinusoidal pattern \cite{kim_automatic_2009} \cite{dam_applied_2014} \cite{noauthor_designing_2003}.

\subsection{Kalman Filtering for Imbalance Estimation}\label{sec:UKF}

Kalman filters have extensive precedent for estimating unknown parameters in dynamic systems for aerospace applications. In traditional spacecraft attitude determination and control, the Extended Kalman Filter (EKF) is the primary method for determining spacecraft body rates and attitude. While a general derivation of the Kalman filter and its variations is beyond the scope of this thesis, a brief background of its application in spacecraft ADCS is important. Here, the state vector of the system is formulated as
\begin{equation}\label{equation:EKF_state_vec}
    \bm{x} = \begin{bmatrix}\bm{\omega} \\ \bm{q} \end{bmatrix}
    =\begin{bmatrix}
        \bm{\omega} \\ \eta \\ \bm{\epsilon}
    \end{bmatrix}
    =\begin{bmatrix}
        \bm{\omega} & q_0 & q_1 & q_2 & q_3
    \end{bmatrix}^T
\end{equation}
where $\bm{q}$ represents the spacecraft's attitude in the form of a quaternion~\cite{de2012spacecraft}. In the standard EKF for spacecraft ADCS, the system state must be discretely propagated forward at each iteration. This is always done through some form of numerical integration, such as
\begin{equation}\label{equation:forward_euler}
    \bm{x}_{k} = \bm{x}_{k-1}+T\bm{f}(\bm{x}_{k-1},\bm{u}_{k-1})
\end{equation}
where $T$ is the discrete sample period, $k$ is the iteration number, and $\bm{u}$ is the control input. \Cref{equation:forward_euler} uses forward Euler integration, but higher-order schemes may also be used. Using quaternion kinematics, an exact expression for $\bm{f}$ can be derived which results in
\begin{equation}
    \bm{f}(\bm{x}_{k-1})=
    \begin{bmatrix}
    
    \bm{J}^{-1}(-\bm{\omega}_{k-1}^{\times}\bm{J}\bm{\omega}_{k-1})+\bm{u}_{k-1} \\

    -\frac{1}{2}\bm{\epsilon}_{k-1}^T\bm{\omega}_{k-1} \\

    \frac{1}{2}(\eta_{k-1}\mathbb{1} +
    \bm{\epsilon}_{k-1}^{\times})\bm{\omega}_{k-1}

    \end{bmatrix}
\end{equation}
where $\bm{\omega}_{k-1}$, $\bm{\epsilon}_{k-1}$, and $\eta_{k-1}$ are all taken directly from $\bm{x}_{k-1}$ according to \Cref{equation:EKF_state_vec}. Next, the propagated state is corrected using a set of measurements $\bm{y}$. These traditionally come from a variety of sensors, namely star trackers, magnetometers, and sun sensors. All of these work as valid measurements provided there is some function that can transform the system state into a measurement using $\bm{y} = \bm{h}(\bm{x})$. The process function and measurement function $\bm{f}$ and $\bm{h}$ may then be used to implement a variety of variations of the Kalman filter to obtain estimates of the state in the presence of process noise and measurement noise.

The Kalman Filter has also been applied to estimate the imbalance vector of spacecraft simulators. Silva provides a survey of a these filtering approaches and their performance \cite{silva_filtering_2018}. In practice, filters struggle to converge on values for $r_x$, $r_y$, and $r_z$ simultaneously. However, reliable convergence can be achieved for $r_z$ when $||r_x||\ll\,||r_z||$ and $||r_y||\ll\,||r_z||$. In other words, filtering can be applied to estimate the vertical balance after the horizontal balance has already been componensated.

To estimate the vertical imbalance $r_z$, the state vector of the dynamic system is written as 
\begin{equation}
    \bm{x} = \begin{bmatrix} \bm{\omega} & \bm{q} & r_z \end{bmatrix}^T
\end{equation}
and the associated process model $\bm{f}(\bm{x}_{k-1})$ is
\begin{equation}\label{equation:UKF_process}
    \bm{f}(\bm{x}_{k-1}) = \begin{bmatrix}
        \bm{J}^{-1}(-\bm{\omega}_{k-1}^\times \bm{J\omega}_{k-1} + m_s
        (\begin{bmatrix}
            0 & 0 & r_z
        \end{bmatrix}^T)^{\times}\bm{g}_{k-1})
        \\
        -\frac{1}{2}\bm{\epsilon}_{k-1}^T\bm{\omega}_{k-1} 
        \\
        \frac{1}{2}(\eta_{k-1}\mathbb{1} + \bm{\epsilon}_{k-1}^{\times})\bm{\omega}_{k-1}
        \\
        0
    \end{bmatrix}
\end{equation}
 While sensors like star trackers and magnetometers are crucial for precise attitude determination, filtering for the imbalance component $r_z$ with a free tumbling simulator can be done using solely body rate measurements. The measurement vector with this approach then is simply $\bm{y}=\bm{\omega}$ and the measurement equation becomes
\begin{equation}
    \bm{h}(\bm{x})= \begin{bmatrix}
        \mathbb{1}_{3\times\,3} & \bm{0}_{3\times\,5}
    \end{bmatrix}\bm{x}
\end{equation}

This process and measurement model serve again as a baseline to implement a filtering method. Here, an Unscented Kalman Filter (UKF) is used due to its improved handling of nonlinearites when compared to the EKF. The torque due to gravity introduces a high amount of nonlinearity to the system, which is challenging for the EKF where the process model is linearized. As demonstrated in the following section, this improved performance comes at the expense of a higher computational cost. However, because measurement data is collected during tumbling and then fed into the filter offline, no constraint is placed on computation time, making the UKF a practical and robust option.

\subsubsection{The Unscented Kalman Filter}

The UKF represents the uncertainty in the current state estimate and covariance using a set of sample points known as sigma points~\cite{wan2000unscented}. These points are distributed symmetrically about the current best estimate of the system's state $\bm{x}_{k-1}$, which represents the mean of the distribution. 

The set of sigma points is given by
\begin{equation}
    \bm{X}_{k-1}^{(i)} =
    \begin{cases}
        \bm{x}_{k-1}, & i = 0 \\[3pt]
        \bm{x}_{k-1} + \bm{r}_i, & i = 1,\dots,n\\[3pt]
        \bm{x}_{k-1} - \bm{r}_{i-n}, & i = n+1,\dots,2n
    \end{cases}
\end{equation}
where $\bm{r}_i$ are the columns of $\sqrt{(n+\lambda)\bm{P}_{k-1}}$. The scaling parameter $\lambda = \alpha^2(n+\kappa) - n$ is computed from the tuning parameters $\alpha$ and $\kappa$, which control the spread and weighting of the sigma points.

Each sigma point is then propagated through the process model $\bm{f}(\cdot)$ given in \Cref{equation:UKF_process}
\begin{equation}
    \bm{X}_k^{(i)} =  \bm{X}_{k-1}^{(i)} + T\bm{f}(\bm{X}_{k-1}^{(i)})
\end{equation}

By propagating a full distribution of representative states through the nonlinear process, the effects of nonlinearity are better captured in the filter. The predicted mean and covariance are computed solely from the set of propagated sigma points. 
\begin{equation}
    \bm{x}_k^- = \sum_{i=0}^{2n} W_m^{(i)} \bm{X}_k^{(i)}, \qquad
    \bm{P}_k^- = \sum_{i=0}^{2n} W_c^{(i)}(\bm{X}_k^{(i)} - \bm{x}_k^-)(\bm{X}_k^{(i)} - \bm{x}_k^-)^T + \bm{Q}_k,
\end{equation}
where $\bm{Q}_k$ is the tunable process noise covariance matrix. The weights $W_m^{(i)}$ and $W_c^{(i)}$ represent the mean and covariance weights respectively, and are defined as
\begin{align}
    W_m^{(0)} &= \frac{\lambda}{n+\lambda}, &
    W_c^{(0)} &= \frac{\lambda}{n+\lambda} + (1-\alpha^2+2),\\
    W_m^{(i)} &= W_c^{(i)} = \frac{1}{2(n+\lambda)}, \quad i=1,\dots,2n
\end{align}

For the correction step, each propagated sigma point is first passed through the measurement model 
\begin{equation}
    \bm{Y}_k^{(i)} = \bm{h}(\bm{X}_k^{(i)}),
\end{equation}
and the predicted measurement and measurement covariance are
\begin{align}
    \hat{\bm{y}}_k^- &= \sum_{i=0}^{2n} W_m^{(i)} \bm{Y}_k^{(i)},\\
    \bm{P}_y &= \sum_{i=0}^{2n} W_c^{(i)}(\bm{Y}_k^{(i)} - \hat{\bm{y}}_k^-)(\bm{Y}_k^{(i)} - \hat{\bm{y}}_k^-)^T + \bm{R}_k
\end{align}
where $\bm{R}_k$ is the tunable measurement noise covariance matrix. The cross-covariance between the state and measurement is
\begin{equation}
    \bm{P}_{xy} = \sum_{i=0}^{2n} W_c^{(i)}(\bm{X}_k^{(i)} - \bm{x}_k^-)(\bm{Y}_k^{(i)} - \hat{\bm{y}}_k^-)^T
\end{equation}

The Kalman gain in the UKF is a function of the cross-covariance matrix and measurement covariance matrix defined as 
\begin{equation}
    \bm{K}_k = \bm{P}_{xy}\bm{P}_y^{-1}
\end{equation}
Finally, the state and covariance are corrected using the actual measurement $\bm{y}_k$ as
\begin{align}
    \bm{x}_k &= \bm{x}_k^- + \bm{K}_k(\bm{y}_k - \hat{\bm{y}}_k^-),\\
    \bm{P}_k &= \bm{P}_k^- - \bm{K}_k\bm{P}_y\bm{K}_k^T
\end{align}
The filter outputs the estimate for $r_z$ directly from $\bm{x}_k$, and proceeds to the next timestep by setting $\bm{x}_k\rightarrow\bm{x}_{k-1}$ and $\bm{P}_k\rightarrow\bm{P}_{k-1}$.


\subsection{Active Control for Balancing}\label{sec:active_methods}

In active balancing methods, the positions of each mass are controlled in real time by linear actuators. The control law is designed to reduce the effect of the $m_s\bm{r}^{\times}\bm{g}$ in the original equations of motion to zero. The torques commanded may be generated with momentum exchange devices or by actuating the masses. If the latter is chosen, the original equations of motion are formulated as
\begin{equation} \label{equation:EomWithTau}
    \bm{J}\dot{\bm{\omega}} + \bm{\omega}^\times \bm{J\omega} 
    = m_s(\bm{r}_0+\Delta\bm{r})^{\times}\bm{g}
\end{equation}
and using the linearity of the cross product, the above equation becomes
\begin{equation} \label{equation:EomWithTau}
    \bm{J}\dot{\bm{\omega}} + \bm{\omega}^\times \bm{J\omega} 
    = m_s\bm{r}_0^{\times}\bm{g} + m_s\Delta\bm{r}^{\times}\bm{g}
\end{equation}
The relationship between mass actuation and torque is found to be
\begin{equation} 
    m_s\Delta\bm{r}^{\times}\bm{g} = \bm{\tau}
\end{equation}
Thus a commanded torque $\bm{\tau}$ may be converted into a value for $\Delta\bm{r}$ using
\begin{equation}\label{equation:torque_to_del_r}
    \Delta\bm{r}=\frac{\bm{g}^{\times}\bm{\tau}}{m_s||\bm{g}||^2}
\end{equation}
and the corresponding commanded positions for each mass are found using \Cref{equation:delta_d_sol} or \Cref{equation:delta_d_pseudo_sol}. If torques are generated in this manner, then the system becomes underactuated as the masses can only generate torques orthogonal to the gravity vector. For the analysis of these methods, it is useful define the projection operation $\bm{P}$ as
\begin{equation}
    \bm{P}=\mathbb{1}-\frac{\bm{g}(\bm{g}^T)}{||\bm{g}||^2}
\end{equation}
Multiplication of any vector by $\bm{P}$ will project the vector into the plane orthogonal to  $\bm{g}$ \cite{choi_automatic_2016}. Let $\bm{v}_p$ be the component of $\bm{v}$ orthogonal to $\bm{g}$ and $\bm{v}_g$ be the component of $\bm{v}$ parallel to $\bm{v}$. Both may be computed using the following
\begin{equation}
    \bm{v}_p = \bm{Pv},\qquad
    \bm{v}_g=\bm{v}-\bm{v}_p
\end{equation}
Because of the underactuation constraint, the methods described in \Cref{sec:under_PID} and \Cref{sec:under_adaptive} only guarantee to place the resulting center of mass in line with the gravity vector, or equivalently, it may only be used to balance $r_x$ and $r_y$. \Cref{sec:3_axis_adaptive} describes a method to simultaneously balance all three componenets of $\bm{r}$ with the aid of momentum exchange devices. 

\subsubsection{Underactuated PID Control}\label{sec:under_PID}

A straightforward approach to reduce the gravity torque to zero is to command the simulator into an equilibrium where $\hat{\bm{z}}_B=-\hat{\bm{g}}$ using solely the sliding masses. Such a position is shown in \Cref{fig:mbs_null_sol}. If the system converges to a state where $\hat{\bm{z}}_B=-\hat{\bm{g}}$ and no control torques are being applied, then it must be the case that $r_x=r_y=0$, though nothing can be concluded for $r_z$.

A quaternion feedback controller can be used to command the system into this state. The desired quaternion is converted from a set of desired Euler angles where roll and pitch equal 0, and yaw is arbitrary. Letting $\bm{q}_d$ be this desired quaternion, the error quaternion $\bm{q}_e$ is calculated with
\begin{equation}
    \bm{q}_e = \bm{q}_d\otimes\bm{q}
\end{equation}
where $\otimes$ represents noncommutative quaternion multiplication defined in this work as
\begin{equation}
\bm{q}_1\otimes\bm{q}_2 = \begin{bmatrix}
    \eta_1          & -\bm{\epsilon}_1^T \\
    \bm{\epsilon}_1 & \eta_1\mathbb{1}+\bm{\epsilon}_1^{\times}
\end{bmatrix}\bm{q}_2
\end{equation}
The commanded torque is then computed from this error. Many spacecraft feedback controllers use a law of the form
\begin{equation}\label{equation:spacecraft_PD}
    \bm{\tau} = -\bm{K}_p\,sign(\eta_e)\bm{\epsilon}_e-\bm{K}_d\bm{\omega}
\end{equation}
which functions as a PD controller with $\bm{K}_p$ and $\bm{K}_d$ representing proportional and derivative gains \cite{de2012spacecraft}. In the presence of a constant disturbance such as gravitational torques, a PD controller alone will accumulate steady-state error. To extend this to a simulator under the influence of gravity, integral action must be added. The modified control law is
\begin{equation}
    \bm{\tau} = -\bm{K}_p\,sign(\eta_e)\bm{\epsilon}_e
    -\bm{K}_i\int\,sign(\eta_e)\bm{\epsilon}_e\,dt
    -\bm{K}_d\bm{\omega}
\end{equation}
where $\bm{K}_i$ is a new integral gain. Generating this torque using sliding masses means that $\tau_z$ will be ignored in the mapping from \Cref{equation:torque_to_del_r}. In practice, this causes the simulator to have no control about its yaw axis which is permissible here since the desired state of ${\bm{z}}_B=-\hat{\bm{g}}$ is independent of yaw.

\begin{figure}
    \centering
    \input{figures/mbs_null_sol.tikz}
    \caption{A center of mass placement that reduces the torque due to gravity to zero, but does not vertically balance the simulator}
    \label{fig:mbs_null_sol}
\end{figure}

\subsubsection{Underactuated Adaptive Control}\label{sec:under_adaptive}
An alternative approach to horizontally balancing the platform using solely the sliding masses is developed by Chesi~\cite{chesi_automatic_2014}. This approach derives an estimator for the initial imbalance vector using a Lyapunov-based analysis. The estimate for the initial imbalance is denoted by $\hat{\bm{r}}_0$ and the error of the estimator is denoted as $\tilde{\bm{r}}_0$. The two values are related by 
\begin{equation}\label{equation:r_relations}
    \bm{r}_0= \tilde{\bm{r}}_0+\hat{\bm{r}}_0
\end{equation} 

The equations of motion remain the same with a control torque $\bm{\tau}$ introduced
\begin{equation} \label{equation:EomWithTau}
    \bm{J}\dot{\bm{\omega}} + \bm{\omega}^\times \bm{J\omega} 
    = m_s\bm{r}_0^{\times}\bm{g} + \bm{\tau}
\end{equation}
and proposed control torque is defined as
\begin{equation}\label{equation:proposed_adaptive}
    \bm{\tau} = m_s\bm{g}^\times\bm{\hat{r}}_0 - k_p\bm{\omega}_p
\end{equation}
where $k_p$ is a tunable gain. $\hat{\bm{r}}_0$ is determined by the proposed adaptive law given by
\begin{equation} \label{equation:adaptive_law}
    \dot{\hat{\bm{r}}}_0 = -(m_s\bm{g}^{\times})^T\bm{\omega}
\end{equation}

To determine the stability of the closed-loop system, a Lyapunov analysis is performed, with the chosen states for analysis being $\bm{\omega}$ and $\tilde{\bm{r}}_0$. The Lyapunov function and its derivative are chosen to be 
\begin{equation}
    {V} = \frac{1}{2}\bm{\omega}^T\bm{J\omega} + \frac{1}{2}\tilde{\bm{r}}_0^T\tilde{\bm{r}}_0
\end{equation}
\begin{align}
    \dot{V} &= \bm{\omega}^T(-\bm{\omega}^\times \bm{J\omega} 
    -m_s\bm{g}^{\times}\bm{r}_0 + \bm{\tau}) 
    + \tilde{\bm{r}}_0^T\dot{\tilde{\bm{r}}}_0 
\end{align}

By substituting \Cref{equation:r_relations}, \Cref{equation:proposed_adaptive}, and \Cref{equation:adaptive_law} into $\dot{V}$, it can be shown that the simplified result is
\begin{equation}\label{equation:final_V_dot}
    \dot{V} = -k_p||\bm{\omega}_p||^2
\end{equation}

Since $\dot{V}$ is negative semidefinite, the closed-loop system is Lyapunov stable. Additionally, under LaSalle's Invariance Principle, the system's state will converge to the largest invariant set in $\{\bm{x}:\dot V(\bm{x})=0 \}$, or $\{\bm{\omega}_p=\bm{0}\}$. Referring again to \Cref{fig:mbs_null_sol}, this corresponds to a state where the simulator is upright ($\hat{\bm{z}}_b$ points opposite of $\bm{g}$) and has no angular velocity about its horizontal axes ($\omega_x=\omega_y=0$). 

\subsubsection{3-Axis Adaptive Control}\label{sec:3_axis_adaptive}
Kim and Argawal developed a 3-axis adaptive control law that uses MEDs as a method to externally excite the platform \cite{kim_automatic_2009}. The excitation is chosen such that the simulator is never able to settle in the state shown in \Cref{fig:mbs_null_sol}. By ensuring that $\bm{r}$ is never parallel to $\bm{g}$, the only way to reduce the contribution of the term $m_s\bm{r}^{\times}\bm{g}$ in \Cref{equation:EomWithTau} to zero is to force the norm of $\bm{r}$ to be zero, thus simultaneously balancing $r_x$, $r_y$, and $r_z$. 

Let $\bm{h}_s$ denote the total angular momentum of the simulator excluding MEDs, which under the assumption from \Cref{equation:h_m_eq_0} is simply computed by $\bm{h}_s=\bm{J\omega}$. Next, let $\bm{h}_d$ be a predetermined desired momentum of the simulator. The proposed 3-axis control law is
\begin{equation}
    \bm{\tau}=\bm{K}(\bm{h}_s-\bm{h}_d)+\bm{\omega}^{\times}\bm{h}_s+\dot{\bm{h}}_d
\end{equation}
where $\bm{K}$ is a tunable gain matrix that must be symmetric positive-definite (SPD). It is important to make the distinction here that $\bm{\tau}$ is purely generated by external MEDs and not the sliding masses. The sliding masses positions' are rather governed by a new adaptive law
\begin{equation}\label{equation:3_axis_adaptive_law}
    \Delta\dot{\bm{r}}=m_s\bm{\Gamma}(\bm{g}^{\times})^T(\bm{h}_s-\bm{h_d})
\end{equation}
where $\bm{\Gamma}$ is another tunable SPD matrix. The original equations of motion from \Cref{equation:EomWithTau} with the above $\bm{\tau}$ substituted are
\begin{equation}
    \dot{\bm{h}_s}+\bm{\omega}^{\times}\bm{h}_s=m_s\bm{r}^{\times}\bm{g}+
    \bm{K}(\bm{h}_s-\bm{h}_d)+\bm{\omega}^{\times}\bm{h}_s+\dot{\bm{h}}_d
\end{equation}
which when simplified and rearranged leads to the result
\begin{equation}\label{equation:h_dot_result}
    \dot{\bm{h}_s}-\dot{\bm{h}}_d=m_s\bm{r}^{\times}\bm{g}+
    \bm{K}(\bm{h}_s-\bm{h}_d)
\end{equation}

To determine the behavior of the proposed controller, a Lyapunov function and its derivative are introduced. Letting $\bm{e}_h=\bm{h}_s-\bm{h}_d$ be the error between the desired and actual momentum, $V$ and $\dot{V}$ may be written as
\begin{equation}
    V(\bm{e}_h,\Delta\bm{r})=\frac{1}{2}\bm{e}_h^T\bm{e}_h
    +\frac{1}{2}(\bm{r}_0+\Delta\bm{r})^T\bm{\Gamma}^{-1}(\bm{r}_0+\Delta\bm{r})
\end{equation}
\begin{equation}
    \dot{V}=\bm{e}_h^T\dot{\bm{e}}_h
    +(\bm{r}_0+\Delta\bm{r})^T\bm{\Gamma}^{-1}\Delta\dot{\bm{r}}
\end{equation}
After substituting the proposed adaptive law in \Cref{equation:3_axis_adaptive_law} and the result from \Cref{equation:h_dot_result}, the derivative simplifies to 
\begin{equation}
    \dot{V}=-\bm{e}_h^T\bm{K}\bm{e}_h
\end{equation}
$\dot{V}$ is negative semidefinite, so the system is Lyapunov stable. Again, under LaSalle's Invariance Principle, the system's state will converge to the largest invariant set in $\{\bm{x}:\dot V(\bm{x})=0 \}$, or $\{\bm{e}_h=\bm{0}\}$. The error dynamics from \Cref{equation:h_dot_result} in this set are
\begin{equation}
    \dot{\bm{e}}_h=m_s\bm{r}^{\times}\bm{g}
\end{equation}
To satisfy invariance, $\dot{\bm{e}}_h$ must equal $\bm{0}$, and if the MEDs ensure that $\bm{r}$ and ${\bm{g}}$ are never parallel, then the system must approach a state where $||\bm{r}||=\bm{0}$. Thus, the proposed controller simultaneously balances $r_x$, $r_y$, and $r_z$.

\section{Implementation on the Cal Poly Spacecraft Attitude Dynamics Simulator (SADS)}

To apply the previously mentioned balancing methods to Cal Poly's SADS, significant progress was made on its design both at the software and hardware levels. This chapter details this design process and the practical implementation considerations.

\subsection{Mechanical}

The goal of the mechanical design was to build on the work completed by Gilman and develop a set of low-cost linear actuators that finely control the position of mass blocks. The iteration developed by Gilman uses two sliding mass units per body axis (six total) \cite{gilman_automatic_2024}. This layout is retained in this work, and it will be assumed each pair of masses per axis will travel in unison from the linear actuator commands. This effectively makes the platform function as if it has three orthogonal masses and simplifies the analysis. Taking lessons learned from previous iterations, the second main goal was to ensure that the size of the mass blocks was easily configurable, thus making the resulting center of mass envelope adjustable. 

\subsubsection{Mass Sizing}

While the exact final design and mass properties of the SADS is unknown, it is still important to place an approximate upper bound on the size of the mass blocks driven by the linear actuators. This ensures that the motors and mounting hardware are not oversized and do not excessively increase the simulator's moment of inertia.

 \Cref{fig:final_CAD} shows the final design of the CAD model for reference. The two heaviest systems onboard are the reaction wheels and the mass balancing system itself. One important aspect of the SADS when designing its desired center of mass envelope is its symmetrical design. For example, the pyramidal reaction-wheel configuration contributes little horizontal imbalance. Additionally the wheels are roughly on the same horizontal plane as the platform's center of rotation, so they also contribute little vertical imbalance. The main source of imbalance will thus be introduced by relatively smaller components like batteries, sensors, the flight computer, and other miscellaneous electronics.

 \begin{figure}[h]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/full_CAD.png}
    \caption{Final CAD design with all major mass contributions included, built off model completed in~\cite{gilman_automatic_2024}}
    \label{fig:final_CAD}
\end{figure}

To approximate a worst case horizontal imbalance, the heaviest of these smaller components---the main 24V battery---was placed in CAD in multiple unfavorable positions with the resulting imbalance vector in the CAD software recorded. The black prism in \Cref{fig:final_CAD} represent this battery, and its position is placed at various edges along the top deck of the simulator. The resulting horizontal center of mass bounds predicted by CAD are $||r_x|| < \SI{0.0078}{\meter}$ and $||r_y|| < \SI{0.0078}{\meter}$. After adding margin to the design, the final horizontal center of mass envelope is designed to be $\text{max}||\Delta\,r_x||=\text{max}||\Delta\,r_y||\approx\SI{0.01}{\meter}$. With a travel distance of $\pm\SI{110}{\mm}$ per rail, the total mass for each horizontal axis is designed as $m_i = \SI{1.4}{\kg}$.

With the horizontal mass sizing complete, the vertical mass sizing takes a slightly different approach. Because the reaction wheels and horizontal sliding masses are positioned slightly below the center of rotation of the platform, the center of mass of the platform with no vertical masses is biased towards $-\hat{\bm{z}}_b$. The vertical masses are sized such that when they are both in their centered positions, the vertical imbalance predicited by CAD is zero. For the vertical sliders, the designed value is $m_i = \SI{0.65}{\kg}$. 

\subsubsection{Linear Actuator Design}

The main goal with the new linear actuator is to address issues faced in the previous iteration, where the DC motors struggled to drive the sliding masses~\cite{gilman_automatic_2024}. This issue is addressed in the new design in a variety of ways. The first is the 6V DC motors that drive the ballscrew shaft are swapped for 24V stepper motors. Even though the old DC motors use a 99:1 gear ratio, the torque output of the 24V stepper motors is still more favorable at low shaft speeds. The next change is the replacement of the linear rails. On its own, a ballscrew has one rotational degree of freedom about the shaft axis that must be restricted for it to linearly travel with no rotation. This restriction is done using a linear rail that travels alongside the ballscrew, and it was observed the old linear rails introduced a significant amount of friction. A new set of rails are integrated that feature recirculating linear bearings. Finally, the ballscrew itself was found to also be introducing friction, and so each ballscrew was disassembled and serviced to reduce friction.


Another issue that was quickly identified with the previous design is that to remove or install mass plates from each rail, the entire linear actuator assembly had to be disassembled. This is addressed by manufacturing a new set of mass plates, with the comparison between the two iterations shown in \Cref{fig:plate_comparison}. The most notable change is the introduction of a slot that connects the edge of the plate to the circular cutout for the ballscrew shaft. As shown in \Cref{fig:linear_act}, this allows plates to be slid directly onto the ballscrew without any disassembly. The slot is also large enough to accommodate the new linear rail, also shown in \Cref{fig:linear_act}. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{figures/plate_comparison.png}
    \caption{Comparison between the previous iteration of mass plates (left) and the newly manufactured plates (right)}
    \label{fig:plate_comparison}
\end{figure}

The final assembly is shown in \Cref{fig:completed_block}, which is completed by adding one plate with a smaller cutout slot to each end. The slot is small enough to prevent the inserted linear rail from sliding out, but still large enough to fit over the ballscrew shaft. The new assembly was verified early in the design stage via open-loop stepper motor position updates, with the exact motor control scheme discussed in the next section. The steps taken to minimize friction within the system proved to have a high impact. In fact, the ballscrews shafts are now adjustable by hand, even when fully loaded and integrated onto the simulator. The ability to quickly add and remove mass plates makes handling the simulator far more convenient as well. Finally, the center of mass envelope using this new system is customizable. The envelope may be expanded by simply integrating more mass plates onto the stack, and it may be reduced by swapping out steel mass plates for 3D-printed equivalents.

\begin{figure}[p]
  \centering
  \begin{subfigure}[t]{0.45\textwidth}
    \includegraphics[width=\linewidth]{figures/linear_act_1.png}
    \caption{Assembly with just ballscrew and linear rail}
  \end{subfigure}\hfill
  \begin{subfigure}[t]{0.45\textwidth}
    \includegraphics[width=\linewidth]{figures/linear_act_2.png}
    \caption{Assembly just before adding the final mass plate}
  \end{subfigure}
  \caption{Mass block assembly with linear rail in CAD}
  \label{fig:linear_act}
\end{figure}

\begin{figure}[p]
    \centering
    \includegraphics[width=0.85\linewidth]{figures/completed_block.jpg}
    \caption{The final mass block assembly}
    \label{fig:completed_block}
\end{figure}

Continuing the goals of~\cite{gilman_automatic_2024}, the final design still has the additional benefit of being low cost. The ballscrews, motors, and linear rails can be easily and cheaply acquired from the consumer CNC market, and the new mass plates are manufactured using Cal Poly's water jet cutter.
\iffalse
\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\linewidth,angle=-90]{figures/new_mbs_pic.jpg}
    \caption{The SADS and air bearing support with the new mass balance system integrated}
    \label{fig:new_mbs_pic}
\end{figure}
\fi
\subsection{Electrical}\label{sec:electrical}

The primary goal of the electrical design is to interface the newly developed linear actuators and an IMU to the onboard computer. All key eletrical connections are documented in \Cref{fig:wiring}. An STM32F446RE was chosen as the primary onboard computer. This board has a high number of GPIO pins, a maximum clock speed of 180 MHz, is low cost, and has proven compatibility with Simulink for code generation. It additionally has a floating point unit that operates on 32-bit floats, which is crucial for the rapid matrix multiplication needed to propagate a Kalman filter in real-time. Despite these benefits, using a microcontroller still has numerous drawbacks, the main one being the need to reflash the board to switch between programs. Future work for the onboard computer is discussed further in \Cref{chap:conclusion}.

\begin{figure}[p]
    \centering
    \includegraphics[width=\linewidth,angle=-90]{figures/wiring.png}
    \caption{Wiring schematic}
    \label{fig:wiring}
\end{figure}

The MTi-03 was chosen as the IMU for its noise characteristics and ease of integration with the STM32. While the LN-200 IMU used in previous iterations of the SADS has excellent noise characteristics, it comes with an extensive integration process and unproven compatibility with STM32. To minimize the risk associated with this project, the MTi-03 is chosen and integration of the LN-200 is left as future work. The MTi-03 has a noise density of $0.003\si{\degree\per\second\per\Hz^{1/2}}$, which is favorable when compared to the values found on existing balancing systems as shown in \Cref{table:existing_testbeds}. The IMU and onboard computer communicate over I2C, with more detail provided in \Cref{sec:software}. The IMU and STM32 stack on the simulator is shown in \Cref{fig:OBC}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.80\linewidth]{figures/OBC.jpg}
    \caption{The STM32F446RE, MTi-03, and APC220 (bottom left) integrated onto the simulator}
    \label{fig:OBC}
\end{figure}

Each stepper motor is controlled by a DRV8825 motor driver. The amount of steps required for one full revolution of the shaft is customizable on the DRV8825, but lower values were observed to cause intense vibrations when integrated on the platform. The minimum value that ensured smooth operation was found to be 3200 steps per revolution. Additionally, early simulation results suggested the mass blocks may have to travel as fast as 15\si{\mm\per\second} during active balancing. Since the ballscrews advance at 10\si{mm} per revolution, this means the onboard computer will need to generate a maximum of 4800 steps per second per motor. Generating steps at this rate on the STM32 caused timing issues with other simultaneous tasks  such as I2C communications and filter propagation. To reduce computational load, the STM32 instead sends the desired shaft position of each motor to a separate Teensy 4.0 over I2C which handles all of the required step generation.

The final two interfaces with the onboard computer are the APC220 and reaction wheel interface. The APC220 communicates over UART with the STM32 to send telemetry wirelessly to a host PC. Since the simulator has full rotational freedom about yaw, telemetry during live air-bearing tests cannot be sent through a wired connection. The reaction wheel interface communicates over I2C with the STM32 which accepts wheel speed commands. Reaction wheel control is discussed in work by Nalley~\cite{nalley2025development}. \Cref{fig:wiring} shows a simplified wiring diagram of the system including all of the boards discussed in this section.


\subsection{Software}\label{sec:software}

The goal of the software design is to utilize Simulink Coder with the STM32 to make the implementation of the discussed balancing algorithms simpler. For this method to be viable, the Simulink model must interface with the external boards in the system as discussed in \Cref{sec:electrical}. 

The most challenging interface is the MTi-03 IMU, which communicates using the XBus communication protocol. The MTi-03 has various data pipes depending on which address is read over I2C. In nominal operations, the IMU collects measurement data and sends it to the measurement pipe, which operates as a first-in-first-out buffer. The amount of data in this buffer is stored in the pipe status address. For each new measurement, the onboard computer must first request the pipe status, read the proper amount of bytes from the measurement pipe, and finally unpack the raw XBus message into gyroscope and accelerometer readings. 

To aid users, the manufacturer Movella provides an XBus library which has numerous functions to aid in this process. Because the library is written in C/C++, a MATLAB System Object is developed which bridges the gap between the XBus library and the standard MATLAB/Simulink environment. The primary data flows within the software are shown in \Cref{fig:software_flowchart}. Once the System Object outputs the raw gyroscope and accelerometer into the model, the majority of the remaining computation occurs in the MATLAB/Simulink environment. The high amount of matrix and vector manipulation within the EKF and control laws makes this environment preferred to C/C++. 

\begin{figure}[h]
    \centering
    \input{figures/software_flowchart.tikz}
    \caption{Functional software architecture during balancing}
    \label{fig:software_flowchart}
\end{figure}

In addition to the Embedded Simulink model, a separate configuration program was written in C. In this program the operator communicates with the STM32 on a host PC in a terminal-like environment over UART. The program allows various system parameters to be configured like the MTi-03 sample rate and sliding mass homing positions. Debugging system issues here is also far more convenient than the Simulink model since the STM32 can print out debug telemetry in the terminal.

\subsection{Algorithm Implementation}

The above work provides a foundation for quickly implementing the various balancing methods described in Sections \labelcref{sec:LSR} through \labelcref{sec:active_methods}. The algorithms are first implemented and verified in the simulation environment described in \Cref{sec:sim_setup}, and then are transferred to the embedded Simulink model for experimental test.

\subsubsection{Onboard Filtering for Attitude Determination}\label{sec:EKF}

For most balancing methods, the onboard computer must calculate a value for $\bm{q}$ in real-time. To accomplish this, an Extended Kalman Filter is implemented in the MATLAB/Simulink environment which is then autocoded and deployed on the STM32. The goal of this filter is to propagate the state forward using the gyroscope output, and correct it with the accelerometer. The onboard EKF state then is simply $\bm{x} = \bm{q}$. If a balancing algorithm requires a value for $\bm{\omega}$, the gyroscope output is used. The state is propagated using
\begin{equation}\label{equation:EKF_process}
    \bm{x}_k^-=\bm{x}_{k-1} + T\begin{bmatrix}
    
    -\frac{1}{2}\bm{\epsilon}_{k-1}^T\bm{\omega}_{k-1} \\
    \frac{1}{2}(\eta_{k-1}\mathbb{1} +
    \bm{\epsilon}_{k-1}^{\times})\bm{\omega}_{k-1}
\end{bmatrix}
\end{equation}
where $\bm{x}_k^-$ is the predicted state, and $\bm{\omega}$ is taken directly from the gyroscope readings. Next, the state is corrected using the accelerometer reading, where the accelerometer output is treated as a measurement for $\bm{g}_b$. Measurements are predicted using 
\begin{equation}\label{equation:EKF_meas}
    \hat{\bm{y}}_k^-=
    \begin{bmatrix}    
    \eta_k^-\mathbb{1}-(\bm{\epsilon}_k^-)^{\times} & -\bm{\epsilon}_k^-
    \end{bmatrix}
    \begin{bmatrix}    
    \bm{g}^\mathcal{N} & (\bm{g}^\mathcal{N})^{\times} \\
    \bm{0} & - (\bm{g}^\mathcal{N})^T
    \end{bmatrix}
    \begin{bmatrix}    
    \eta_k^- \\
    \bm{\epsilon}_k^-
    \end{bmatrix}
\end{equation}
where $\eta_k^-$ and $\bm{\epsilon}_k^-$ are taken from $\bm{x}_k^-$, and $\bm{g}^\mathcal{N}=[0, 0,-9.81]^T$

In reality, unless the accelerometer is perfectly aligned with the simulator's center of rotation, the sensor output will include the effects of centripetal acceleration. However, since the MTi-03 IMU is mounted close to the center of rotation on the SADS and the body rates of the simulator during balancing are low, the effects of centripetal acceleration are not included in the measurement model.

Following the standard EKF formulation, the process and measurement Jacobians are computed. \Cref{equation:EKF_process} is linearized about $\bm{x}_{k-1}$, while \Cref{equation:EKF_meas} is linearized about $\bm{x}_k^-$. The process Jacobian $\bm{F}$ and measurement Jacobian $\bm{H}$ are 
\begin{equation}
    \bm{F}_k = \mathbb{1}+
T\begin{bmatrix}
0 & -\tfrac{1}{2}\bm{\omega}_{k-1}^{T}\\[3pt]
\tfrac{1}{2}\bm{\omega}_{k-1} & -\tfrac{1}{2}\bm{\omega}_{k-1}^{\times}
\end{bmatrix}.
\end{equation}

\begin{equation}
\bm{H}_k =
\begin{bmatrix}
2\!\left(\eta_k^- \mathbb{1} - (\bm{\epsilon}_k^-)^{\times}\right)\bm{g}^{\mathcal N}
\\
-2\,\bm{g}^{\mathcal N}(\bm{\epsilon}_k^-)^{\!T}
+2\!\left((\bm{\epsilon}_k^-)^{\!T}\bm{g}^{\mathcal N}\right)\mathbb{1}
+2\,\bm{\epsilon}_k^- (\bm{g}^{\mathcal N})^{\!T}
+2\,\eta_k^- (\bm{g}^{\mathcal N})^{\times}
\end{bmatrix}^T.
\end{equation}
With $\bm{F}$ computed, the filter propagates the covariance forward using
\begin{equation}
        \bm{P}_k^- = \bm{F}_{k-1}\bm{P}_{k-1}\bm{F}_{k-1}^T + \bm{L}\bm{Q}\bm{L}^T
\end{equation}
where $\bm{Q}$ is the tunable process noise matrix, and $\bm{L}$ relates the process noise to the state and is defined as
\begin{equation}
    \bm{L} = T\begin{bmatrix}
        0      & \bm{0} \\
        \bm{0} & \mathbb{1}_{3\times3}
    \end{bmatrix}\in\mathbb{R}_{4\times4}
\end{equation}
Next the Kalman gain $\bm{K}$ is computed with
\begin{equation}
    \bm{K}_k = (\bm{P}_k^-\bm{H}_k^T)/(\bm{H}_k\bm{P}_k^-\bm{H}_k^T + \bm{R})
\end{equation}
where $\bm{R}$ is the tunable measurement noise matrix.

The filter iteration ends with the state and covariance being corrected using the Kalman gain as follows
\begin{equation}
    \bm{x}_k = \bm{x}_k^- + \bm{K}_k(\bm{y}_{\text{meas},k}-\hat{\bm{y}}_k^-)
\end{equation}
\begin{equation}
    \bm{P}_k = (\mathbb{1} - \bm{K}_k\bm{H}_k)\bm{P}_k^-(\mathbb{1} - \bm{K}_k\bm{H}_k)^T
    + \bm{K}_k\bm{R}\bm{K}_k^T
\end{equation}
where $\bm{y}_{\text{meas},k}$ is the accelerometer reading. At this point the quaternion is normalized using $\bm{x}_k = \bm{x}_k / ||\bm{x}_k||$ and is sent along with $\bm{g}_b$ to the control law, with $\bm{g}_b$ being computed from \Cref{equation:C_from_q}. The filter and the control law both run at 20 Hz in all balancing operations.

The filter as described here still has room for improvement. Including an estimate of the gyroscope bias in the state vector would improve accuracy over longer runs, and there are more sophisticated methods to enforcing a unit norm for $\bm{q}$. However the filter's simulated performance as described in \Cref{sec:sim_setup} proved to be adequate for mass balancing, so improvements to the filter are left as future work with more detail described in \Cref{chap:conclusion}.

\subsubsection{Passive Balancing Operation}

\begin{figure}[p]
    \centering
    \input{figures/passive_flowchart.tikz}
    \caption{Balancing procedures for the experimental test setup}
    \label{fig:operator_flowchart}
\end{figure}


\Cref{fig:operator_flowchart} shows the various balancing procedures applied on the experimental test setup in this work. The passive balancing operation consists of the iterative loops in both branches. With the EKF implemented, passive balancing becomes relatively simple. The operator manually sets the initial attitude of the simulator and begins recording telemetry. The simulator tumbles either freely or under the influence of the open loop reaction wheel commands depending on the balancing method being used. The reaction wheel interface is additionally able to feed back the applied torque, which is logged with the telemetry. Only one reaction wheel is completed and integrated on the SADS, which has implications on the balancing performance as will be discussed in \Cref{chap:results}. The data flows in the system during passive balancing can be seen in \Cref{fig:sys_arch_passive}.

The attitude, body rates, and reaction wheel torques are then loaded onto the host PC. The data is post processed and input into either the UKF or the least-squares estimator depending on the algorithm. Both the UKF and least-squares estimator are implemented in MATLAB directly mirroring the equations as laid out in \Cref{sec:LSR} and \Cref{sec:UKF}. The resulting estimate for $\bm{r}$ is converted into a set of new mass positions $\Delta\bm{r}$, which are finally applied through the stepper motors. This process is repeated until the estimates converge, with the exact conditions for convergence being discussed further in \Cref{chap:results}. 

\begin{figure}[h]
    \centering
    \input{figures/sys_arch_passive.tikz}
    \caption{Primary data flows and components during passive balancing}
    \label{fig:sys_arch_passive}
\end{figure}

\subsubsection{Active Balancing Operation}

Active balancing consists of the first step in the Two-Step Hybrid Method branch on \Cref{fig:passive_flowchart}. For active balancing, the values computed by the EKF are used as input into the various control laws described \Cref{sec:active_methods}. The control laws output a desired torque, which is converted into a desired change in center of mass according to \Cref{equation:torque_to_del_r}, and then further converted into a change of sliding mass positions according to \Cref{equation:delta_d_sol}. The benefits of offloading step generation to the Teensy are again seen here, as the controller ends each timestep by simply performing a short I2C write with the desired positions of each motor. The task of implementing step generation in the Simulink model is entirely avoided. The data flows in the system during active balancing can be seen in \Cref{fig:sys_arch_active}.

To run an active balancing operation, the proper Simulink model is compiled on the host PC and flashed onto the STM32 over USB. The USB is disconnected and the feedback control is activated via button press. The simulator automatically balances, and the operator ends the test when the sliding mass positions converge. The conditions for sliding mass convergence during active balancing are also discussed in \Cref{chap:results}. Telemetry may still be sent over the APC220 to help with plotting results and debugging issues, but is not strictly necessary for the procedure. 

\begin{figure}[h]
    \centering
    \input{figures/sys_arch_active.tikz}
    \caption{Primary data flows and components during active balancing}
    \label{fig:sys_arch_active}
\end{figure}

\section{Simulation Development}\label{sec:sim_setup}

A high-fidelity simulation was developed in Simulink alongside the SADS hardware to help rapidly develop code for the onboard computer. Running the simulation before physical testing allows balancing algorithms to be tuned, debugged, and verified safely before deployment. In fact, large sections of code developed in the simulation environment were directly reused in the embedded Simulink model that is flashed onto onboard computer.

The simulation models the same physical components present in the hardware such as mass properties, actuators, and sensors. It also includes tunable parameters that simulate real-world imperfections such as inertia uncertainty, sensor bias, and wheel misalignment. Modeling these imperfections ensures that results obtained from the hardware test can be better compared against simulated results.

\subsection{Truth vs. Measured Quantities}

An important distinction in this simulation framework is between truth values and measured or estimated values available to the onboard computer. The truth model represents the actual physical dynamics of the simulator, while the onboard algorithms use only noisy and discretized sensor data. By explicitly modeling both sides, the simulation provides a way to quantify how sensor limitations and real-world imperfactions degrade balancing performance.

\subsection{Plant Model}
The plant represents the truth dynamics of the simulator and forms the reference against which onboard estimates are compared. The plant model solves the following differential equation
\begin{equation}
    \dot{\bm{\omega}}_\text{tr} = \bm{J}_\text{tr}^{-1}(-\bm{\omega}_\text{tr}^\times \bm{J_\text{tr}\omega_\text{tr}} 
    - \bm{\omega}_\text{tr}^\times\bm{h}_{c,\text{tr}} + m_s\bm{r}_0^{\times}\bm{g}_\text{tr} + m_s\Delta\bm{r}_\text{tr}^{\times}\bm{g}_\text{tr}
    - \dot{\bm{h}}_{c,\text{tr}})
\end{equation}
which when solved yields $\bm{\omega}_\text{tr}$. Values subscripted with $\text{tr}$ denote true physical values that the onboard computer and balancing algorithm do not have access to. To start, $\bm{J}_\text{tr}$ is used to account for errors in the estimation of $\bm{J}$. Many balancing methods require knowledge of the simulator's moment of inertia $\bm{J}$, and the estimate for this value in this work is taken from CAD. Given the geometry of the SADS is well known and the mass of each compenent is carefully measured, this estimate is assumed to be fairly accurate. Still, to account for errors in the CAD model, the value of inertia used in the truth model $\bm{J}_\text{tr}$ is perturbed from the CAD estimate. This perturbation is performed using
\begin{equation}
    \bm{J}_\text{tr} = \begin{bmatrix}
        a_1\hat{J}_{xx} & a_4\hat{J}_{xy} & a_5\hat{J}_{xz} \\
        a_4\hat{J}_{xy} & a_2\hat{J}_{yy} & a_6\hat{J}_{yz} \\
        a_5\hat{J}_{xz} & a_6\hat{J}_{yz} & a_3\hat{J}_{zz} \\
    \end{bmatrix}\qquad\,a_i\sim\mathcal{N}(1,0.05)
\end{equation}
where the components $\hat{J}_{(ij)}$ are taken from the CAD estimate. The mass of the simulator $m_s$ is a direct measurement from the experimental test setup. The final mass properties used in the simulation are
\begin{equation}
    \hat{\bm{J}} = \begin{bmatrix}
        1.298  & -0.014 & 0.004 \\
        -0.014 &  1.025 & 0.008 \\
        0.004  &  0.008 & 1.243 \\

    \end{bmatrix}\:\text{kg}\cdot\text{m}^2,
    \qquad
    m_s = 29.6\,\text{kg}
\end{equation}

Once the solver obtains $\bm{\omega}_\text{tr}$, the quaternion is obtained using the kinematic differential equation introduced in \Cref{equation:quat_kinematics} and the quaternion is converted into a value for $\bm{g}_\text{tr}$. These truth values for the body rate and gravity vector are then passed onto the sensor model.

\subsection{Sensors}

The sensor model converts $\bm{\omega}_\text{tr}$ and $\bm{g}_{\text{tr}}$ into gyroscope and accelerometer measurements used by the onboard computer. As mentioned earlier, the accelerometer does not directly measure the gravity vector in the body frame, but rather the specific force acting on the sensor which includes the effects of centripetal acceleration. The value $\bm{g}_{b,\text{tr}}$ is discretized according to the 20 Hz sample rate of the filter and control system, indexed by $k$. Finally, the discreted value is corrupted by measurement noise and bias. The complete model for the accelerometer output is
\begin{equation}
    \bm{y}_{\text{accel},k}= (\bm{\omega}_{\text{tr}}^{\times}\bm{r}_\text{IMU})^{\times}\bm{\omega}_{\text{tr}}-\bm{g}_{\text{tr}} + \bm{n}_{\text{accel},k} + \bm{b}_{\text{accel},k}
\end{equation}
where $\bm{r}_\text{IMU}$ is the position of the IMU, and $\bm{n}_{\text{accel},k}$ and $\bm{b}_{\text{accel},k}$ are the contributions from the measurement noise and bias respectively.

The model for the gyroscope output follows in a similar manner as
\begin{equation}
    \bm{y}_{\text{gyro},k}= \bm{\omega}_{\text{tr}} + \bm{n}_{\text{gyro},k} + \bm{b}_{\text{gyro},k}
\end{equation}

The gyroscope and accelerometer measurement noise $\bm{n}_k$ is modeled using the Band-Limited White Noise Block in Simulink, with the parameters being taken from the sensor specifications of the MTi-03 IMU. 

The measurement bias is implemented using a first-order Gauss-Markov Model \cite{unsal_estimation_2012}, which allows $\bm{b}_k$ to be computed using
\begin{equation}
    \bm{b}_{k} = a\,\bm{b}_{k-1} + \bm{w}_k, \qquad
    a = e^{-T_s/T_c}, \qquad
    \bm{w}_k \sim \mathcal{N}\!\left(\bm{0},\,\sigma_x^2 (1-e^{-2T_s/T_c})\,\mathbb{1}\right),
\end{equation}
where $T_c$ is the correlation time constant, $\sigma_x$ is the stationary standard deviation of the bias, and $T_s$ is the sample period. For slow varying bias, $T_c$ is chosen to be large $(\sim2000\text{s})$, and $\sigma_x$ is taken from the sensor specifications of the MTi-03 IMU. 

The final measurements $\bm{y}_{\text{accel},k}$ and $\bm{y}_{\text{gyro},k}$ are passed onto the onboard computer to be used as inputs in the EKF. Referring to \Cref{sec:EKF}, within the EKF these values corresponed to $\bm{y}_{\text{gyro},k}\rightarrow\bm{\omega}_k$ and $\bm{y}_{\text{accel},k}\rightarrow\bm{y}_{\text{meas},k}$.

\subsection{Actuators}

The actuators in the simulation include the sliding masses and reaction wheel pyramid. The controller takes the commanded torque $\bm{\tau}_c$ and converts into desired torques for the four reaction wheels using the allocation matrix $\bm{A}$. For four evenly spaced wheels in a pyramidal configuration, the allocation matrix is
\begin{equation}
    \bm{A} = 
    \begin{bmatrix}
        c & -c & -c &  c \\
        c & c  & -c & -c \\
        s & s & s & s
    \end{bmatrix}
\end{equation}
where $c = \cos(\theta)/\sqrt{2}$, $s = \sin\theta$, and $\theta$ is the wheel elevation angle.

The commanded individual wheel torques are computed in the controller using 
\begin{equation}
    \bm{\tau}_\text{wheels} = \bm{A}^{\dagger}\bm{\tau}_c
\end{equation}
However, when determining the torque acting on the simulator in the truth model, it is important to account for the effects of wheel misalignment. Ideally, the columns of $\bm{A}$ represent the unit vectors of each wheel's spin axis, but manufacturing defects and mounting errors result in the true spin axes deviating slightly. 

 To introduce the effects of wheel misalignment, each nominal wheel spin axis $\hat{\bm{s}}_i$ (the $i$th column of $\bm{A}$) is perturbed by a small angular deviation $\alpha$ in a random direction orthogonal to $\hat{\bm{s}}_i$. The perturbed (true) spin axis $\hat{\bm{s}}_{i,\text{tr}}$ is computed as
\begin{equation}\label{equation:wheel_perturb}
    \hat{\bm{s}}_{i,\text{tr}} = 
    \cos(\alpha)\,\hat{\bm{s}}_i 
    + \sin(\alpha)\,\hat{\bm{t}}_i,
\end{equation}
where $\hat{\bm{t}}_i$ is a random unit vector orthogonal to $\hat{\bm{s}}_i$ that defines the direction of the perturbation. The true allocation matrix $\bm{A}_\text{tr}$ is then
\begin{equation}
    \bm{A}_\text{tr}=\begin{bmatrix}
        \hat{\bm{s}}_{1,\text{tr}} & \hat{\bm{s}}_{2,\text{tr}} & \hat{\bm{s}}_{3,\text{tr}} & \hat{\bm{s}}_{4,\text{tr}}
    \end{bmatrix}
\end{equation}
The value for $\dot{\bm{h}}_{c,\text{tr}}$ used in the plant is then calculated with
\begin{equation}
    \dot{\bm{h}}_{c,\text{tr}} = \bm{A}_\text{tr}\bm{\tau}_\text{wheels}
\end{equation}
For the SADS, a perturbation angle of $1.5^{\circ}$ is chosen to account for the overall structure---which includes the mounting slots for the wheels---being welded. These perturbations are especially important to simulate the performance of the batch estimation method, where measurements of $\dot{\bm{h}}_{c,\text{tr}}$ and $\bm{h}_{c,\text{tr}}$ are used in the estimate for the center of mass offset.  

The sliding mass positions as computed by the control law $\Delta\bm{d}$ are converted into a truth value for $\Delta\bm{r}$ using
\begin{equation}
    \Delta\bm{r}_{\text{tr}} = \bm{U}\bm{M}\left(\Delta\bm{d}+ \mathcal{N}\!\left(\bm{0},\mathbb{1}\cdot10^{-5}\text{m}^2\right)\right)
\end{equation}
where positional uncertainty due to backlash and ballscrew imperfections have been modeled as gaussian white noise. 

The actuator inputs into the plant finally pass through a small first-order lag of the form 
\begin{equation}
    H(s) = \frac{1}{0.005s + 1}
\end{equation}
which approximates factors like IMU sampling latency, onboard computation time, and motor dynamics. Including this term avoids unrealistic instant actuator responses in the simulation while still maintaining numerical stability. 
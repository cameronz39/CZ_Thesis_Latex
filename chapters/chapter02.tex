\chapter{Background}\label{chap:background}
\section{The Mass Balancing Problem}

\begin{figure}
    \centering
    \input{figures/mbs_problem.tikz}
    \caption{The mass balancing problem for air bearing based spacecraft dynamics simulators}
    \label{fig:mbs_problem}
\end{figure}


\Cref{fig:mbs_problem} defines the geometery of the problem in a general case. $O$ represents the common origin of the inertial frame $\mathcal{N}$ and the body-fixed principle frame of the simulator $\mathcal{B}$. $O$ is chosen to be the center of rotation . If frictionless rotation is assumed, then the simulator follows Euler's rotational equations of motion with gravity acting as a torque. 

\begin{equation}
    \bm{J}\,\dot{\bm{\omega}} + \bm{\omega}^{\times}\,\bm{J}\bm{\omega} = \bm{T}_g
\end{equation}

Here, $\bm{J}$ is the inertia of the simulator about $O$, $\bm{\omega}$ is the angular velocity of the simulator, and $\bm{T}_g$ is the torque due to gravity. $\dot{\bm{v}}$ represents the time derivative of some vector $\bm{v}$, and $\bm{v}^{\times}$ represents the skew-symmetric cross-product matrix of $\bm{v}$. All vectors and inertias are expressed in $\mathcal{B}$. In general it is more convienent to expand $\bm{T}_g$ which leads to

\begin{equation}\label{equation:starting_eom}
    \bm{J}\,\dot{\bm{\omega}} + \bm{\omega}^{\times}\,\bm{J}\bm{\omega} = m_s\bm{r}^{\times}\bm{g}
\end{equation}

where $m_s$ is the total mass of the simulator, $\bm{r}$ is the center of mass relative to $O$, and the $\bm{g}$ is the accleration due to gravity.

\Cref{fig:mbs_problem} also shows the introduction of three sliding masses, although in general there may be as many as $n$ sliding masses. Each mass $m_i$ has one translational degree of freedom along $\bm{u}_i$, and $\bm{\rho}_i$ represents the position of the $i$-th mass in it's zeroed position. Since in practice each mass can only travel some limited distance along $\bm{u}_i$, the zeroed position of a mass is defined as the center of this range of positions. The position relative to $O$ of any mass $\bm{R}_i$ can be obtained with 
\begin{equation}\label{equation:sliding masses}
    \bm{R}_i = \bm{\rho}_i + d_i\bm{u_i}
\end{equation}
where $d_i$ is the distance a mass $m_i$ has travelled along $u_i$ relative to it's zeroed position. More generally, $\Delta\,d_i$ is defined as the change in position a mass from any arbitrary starting position.

The goal of these definitions is to obtain an equation relating how changing the positions of each mass effects the center of mass of the total system. These parameters are first assembled into matricies as follows

\begin{equation}
    \bm{M}=\mathrm{diag}(\frac{m_1}{m_s}, \cdots  ,\frac{m_n}{m_s}) \in \mathbb{R}^{n \times n}
\end{equation}
\begin{equation}
    \bm{U}=
    \begin{bmatrix}
        \bm{u}_1, & \cdots & ,\bm{u}_n
    \end{bmatrix}
    \in \mathbb{R}^{3 \times n}
\end{equation}
\begin{equation}
    \Delta\bm{d}=
    \begin{bmatrix}
        \Delta\,d_1, & \cdots & ,\Delta\,d_n 
    \end{bmatrix}^T
    \in \mathbb{R}^{n}
\end{equation}

Using these defintions, writing $\Delta\bm{r}$ as a function of $\Delta\bm{d}$ becomes a simple matrix multiplication

\begin{equation}
    \Delta\bm{r} = \bm{U}\bm{M}\Delta\bm{d}
\end{equation}
 
The more important relation however is writing $\Delta\bm{d}$ as a function of $\Delta\bm{r}$. For the case $n = 3$ with linearly independent values of $\bm{u}_i$, the unique solution is given by
\begin{equation}\label{equation:delta_d_sol}
    \Delta\bm{d} = (\bm{U}\bm{M})^{-1}\Delta\bm{r}
\end{equation}
If $n>3$, a solution that minimizes the mass moved can be found using a pseudoinverse approach
\begin{equation}\label{equation:delta_d_pseudo_sol}
    \Delta\bm{d} = (\bm{U}\bm{M})^{\dagger }\Delta\bm{r}
\end{equation}

where $(\bm{U}\bm{M})^{\dagger}$ represents the Moore-Penrose pseudoinverse of $\bm{UM}$.

There are two main approaches to solving the mass balancing problem. The first is to hold the mass positions constant and obtain an estimate of the value of $\bm{r}$, denoted as $\hat{\bm{r}}$. The required change in positions of the sliding masses are then applied all at once. The exact values are calculated from \Cref{equation:delta_d_sol} or \Cref{equation:delta_d_pseudo_sol}, substituting $-\hat{\bm{r}}$ for $\Delta\bm{r}$. This class of approaches is referred to passive balancing, offline balancing, or the batch estimation method.

The second main approach is to use $\Delta\bm{d}$ as a control input. Referring to \Cref{equation:starting_eom}, the dynamics of the system are influenced by the value of $\bm{r}^{\times}$, whose value can be controlled by $\Delta\bm{d}$ using \Cref{equation:delta_d_sol} or \Cref{equation:delta_d_pseudo_sol}. The goal then becomes to find a feedback control law the drives the effect of the $m_s\bm{r}^{\times}\bm{g}$ term in \Cref{equation:starting_eom} to zero. This class of approaches is referred to as active balancing or feedback control balancing.

Once any balancing procedure has been performed, it is important to verify the results through an external verification method. Assuming the center of mass is below the center of rotation, a very rough estimate for the torque due to gravity may be obtained by tilting the simulator about one of it's principal axes, releasing it, and observing the period of resulting pendulum motion $T$ \cite{kim_automatic_2009}. The relationship between $\bm{r}$ and $T$ is given by
\begin{equation}
    T = 2\pi\sqrt{\frac{J_i}{m_s\,g||\bm{r}||}}
\end{equation}
where $J_i$ is the moment of inertia about said principle axis. After performing a balancing procedure, the value of $||\bm{r}||$ should decrease, leading to longer periods of oscillatation. 

Another verification method is observing the total mechanical energy of the simulator while it undergoes this same pendulum motion. The mechanical energy is given by
\begin{equation}
    E_{mech} = \frac{1}{2}\bm{\omega}^T\bm{J}\bm{\omega} + mgh
\end{equation}
where $h$ is the vertical height of $\bm{r}$ \cite{silva_filtering_2018}. If the simulator is balanced, $h$ will remain relatively constant throughout the pendulum motion, and the kinetic energy term $\frac{1}{2}\bm{\omega}^T\bm{J}\bm{\omega}$ will also remain relatively constant due to the conservation of energy. As the balance of the simulator improves, the kinetic energy will oscillate with smaller amplitudes.

Ideally this value is zero, but in practice mass balancing systems seek to make this value as small as possible while satsifying other project constraints like cost, time, and volume. 

\section{Mass Balancing Hardware}

\section{Batch Estimation Algorithms}

Batch estimation algorithms are a subset of passive balancing methods that use momentum exchange devices to excite the simulator and record the resulting body rate and attitude data. The equations of motion are manipulated to help obtain multiple estimates of $\bm{r}$, and a single, final estimate of $\bm{r}$ is calculated using least-squares error methods. Many variations of batch estimation algorithms exist, but they all start with same principle up seperating the constant mass properties from the dynamic states in the equations of motion. To accomplish this, it helps to define the following variables

\begin{equation}
    \bm{\Omega} =
        \begin{bmatrix}
            \omega_1 & 0 & 0 & -\omega_2 & -\omega_3 & 0 \\
            0 & \omega_2 & 0 & -\omega_1 & 0 & -\omega_3 \\
            0 & 0 & \omega_3 & 0 & -\omega_1 & -\omega_2
        \end{bmatrix}
\end{equation}
\begin{equation}
    \bm{x} = \begin{bmatrix}
        J_{xx} & J_{yy} & J_{zz} & J_{xy} & J_{xz} & J_{yz} & m_s\,r_x & m_s\,r_y & m_s\,gr_z
    \end{bmatrix}^T
\end{equation}

Using these values, the original equations of motion in \Cref{equation:starting_eom} can be rewritten as 
\begin{equation}\label{equation:no_MEDs}
    \begin{bmatrix}
        \dot{\bm{\Omega}}+\bm{\omega}^{\times}\bm{\Omega} & \bm{g}^{\times}
    \end{bmatrix}\bm{x}
    =\bm{0}
\end{equation}
with the goal being to eventually solve for $\bm{x}$. To avoid nullspace solutions (which give physically invalid mass properties), additional terms must be introduced to the right hand side. This is done through the use of momentum exchange devices which changes \Cref{equation:no_MEDs} into 
\begin{equation}\label{equation:with_MEDs}
    \begin{bmatrix}
    \dot{\bm{\Omega}}+\bm{\omega}^{\times}\bm{\Omega} & \bm{g}^{\times}
    \end{bmatrix}\bm{x}
    =-\dot{\bm{h_c}} - \bm{\omega}^{\times}\bm{h_c}
\end{equation}

where $\bm{h}_c$ represents the total angular momentum of the MEDs. Additionally, to avoid taking the numerical derivative of the noisy signal $\bm{\omega}$ (which will come from gyroscopes), both sides of \Cref{equation:with_MEDs} are integrated with resepct to time which results in 
\begin{equation}\label{equation:LSM_no_k}
    \begin{bmatrix}
    \int_{t_0}^{t}\dot{\bm{\Omega}}+\bm{\omega}^{\times}\bm{\Omega}\,dt & \int_{t_0}^{t}\bm{g}^{\times}\,dt
    \end{bmatrix}\bm{x}
    =-{\bm{h_c}} - \int_{t_0}^{t}\bm{\omega}^{\times}\bm{h_c}\,dt
\end{equation}

For each timestep $k$ where a measurement is taken, a new $\bm{A}$ and $\bm{T}$ matrix are created using
\begin{equation}
    \bm{A}_k=\begin{bmatrix}
    \int_{t_0}^{t_k}\dot{\bm{\Omega}}+\bm{\omega}^{\times}\bm{\Omega}\,dt & \int_{t_0}^{t_k}\bm{g}^{\times}\,dt
    \end{bmatrix}
\end{equation}
\begin{equation}
    \bm{T}_k=-{\bm{h_c}} - \int_{t_0}^{t}\bm{\omega}^{\times}\bm{h_c}\,dt
\end{equation}
which allows \Cref{equation:LSM_no_k} to be rewritten as 
\begin{equation}\label{equation:LSM_with_k}
    \bm{A}_k\bm{x}=\bm{T}_k
\end{equation}

Since all measurements are corrupted by noise, there will not be any single value of $\bm{x}$ that will satisfy \Cref{equation:LSM_with_k} for all $k$. Instead, the key idea with least squares estimation methods is to find a value of $\bm{x}$ that minimizes the error in \Cref{equation:LSM_with_k} across all $k$. The most common way to achieve is this to create augmented versions of $\bm{A}$ and $\bm{T}$ as
\begin{equation}
    \bar{\bm{A}}=\begin{bmatrix}
        \bm{A}_0 & \bm{A}_1 & \cdots & \bm{A}_n
    \end{bmatrix}\in \mathbb{R}^{3n \times 9}
\end{equation}
\begin{equation}
    \bar{\bm{T}}=\begin{bmatrix}
        \bm{T}_0 & \bm{A}_1 & \cdots & \bm{T}_n
    \end{bmatrix}\in \mathbb{R}^{3n \times 1}
\end{equation}
where $n$ is the total number of measurements. $\bm{x}$ is finally computed using 
\begin{equation}
    \bm{x}=\bar{\bm{A}}^{\dagger}\bar{\bm{T}}
\end{equation}
The offline batch estimation method requires that multiple tests are run, adjusting the sliding masses after each run using \Cref{equation:delta_d_sol} or \Cref{equation:delta_d_pseudo_sol}. Assuming actuators like reaction wheels are available, this method's main advantage is it's ease of implementation. By doing all of the estimation and data processing offline, no custom software needs to be written for the simulator's onboard computer. In fact, exciting the system using this method does not require the simulator to have a working feedback controller, allowing this method to be adopted early in the design of a simulator. Researches have demonstrated success using simple open loop control to ensure that the body rates of the simulator follow a sinusoidal pattern \cite{kim_automatic_2009} \cite{dam_applied_2014} \cite{noauthor_designing_2003}.



\section{Kalman Filtering for Inbalance Estimation}

Kalman filters have extensive precedent for estimating unknown parameters in dynamic systems for aerospace applications. In traditional spacecraft attitude determination and control, the Extended Kalman Filter is the primary method for determining spacecraft body rates, attitude, and gyroscope biases.  Multiple researchers have extended this to estimate the inbalance vector $\bm{r}$. To do this, the state vector of the dynamic system is written as 
\begin{equation}
    \bm{x} = \begin{bmatrix} \omega_x & \omega_y & \omega_z & r_x & r_y & r_z \end{bmatrix}^T
\end{equation}
and the associated dynamics of the system becomes
\begin{equation}
    \dot{\bm{x}} = \bm{f}(\bm{x}) + \bm{d}(t)
\end{equation}
where 
\begin{equation}
    \bm{f}(\bm{x}) = \begin{bmatrix}
        \bm{J}^{-1}(-\bm{\omega}^\times \bm{J\omega} + m_s\bm{r}^{\times}\bm{g})
        \\
        \bm{0}
    \end{bmatrix}\bm{x}
\end{equation}
and $\bm{d}(t)$ is the process noise.  Assuming an IMU can directly measure the body rates, the measurement equation becomes
\begin{equation}
    \bm{y} = \bm{h}(\bm{x}) + \bm{v}(t)
\end{equation}
where
\begin{equation}
    \bm{h}(\bm{x})=
    \begin{bmatrix}
        \mathbb{1} & \bm{0}
    \end{bmatrix}
\end{equation}
and $\bm{v}(t)$ is the measurement noise. This process and measurement model serve as a basline to implement either an Extended Kalman Filter or Unscented Kalman Filter - with measurements purely being provided by an IMU in the form of $\bm{\omega}$, and the dynamics states $r_x$, $r_y$, and $r_z$ all being filtered for. \cite{silva_filtering_2018} provides an in-depth analysis of these filters' performance and their variations. In practice, filters can struggle to converge on values for $r_x$, $r_y$, and $r_z$ simultaneously. Instead, filtering is used often used to soley filter for $r_z$ (referred to as the vertical inbalnace) when $r_x$ and $r_y$ (referred to as the horizontal inbalance) are relatively small. In this case, $r_x$ and $r_y$ are set to zero and are no longer considered dynamic states. The new state vector becomes
\begin{equation}
    \bm{x} = \begin{bmatrix} \omega_x & \omega_y & \omega_z & r_z \end{bmatrix}^T
\end{equation}

and $\bm{f}(\bm{x})$ and $\bm{h}(\bm{x})$ become

\begin{equation}
    \bm{f}(\bm{x}) = \begin{bmatrix}
        \bm{J}^{-1}(-\bm{\omega}^\times \bm{J\omega} + \begin{bmatrix} \omega_x & \omega_y & \omega_z r_z \end{bmatrix}^T)
        \\
        0
    \end{bmatrix}    
\end{equation}
\begin{equation}
    \bm{h}(\bm{x})= \begin{bmatrix}
        \mathbb{1} & 0
    \end{bmatrix}
\end{equation}

While a general derivation of the Kalman filter and its variations is beyond the scope of this thesis 
\section{Active Control for Balancing}

\section{Cal Poly SADS MBS Design }
\begin{table}[!ht]
\caption{Existing spacecraft dynamics simulators and their balancing methods}\label{table:existing_testbeds}
\centering
\renewcommand{\arraystretch}{1.3}

\begin{tabularx}{\textwidth}{
    >{\raggedright\arraybackslash}p{3cm}   % Institution
    >{\raggedright\arraybackslash}p{3.5cm} % Actuators
    >{\raggedright\arraybackslash}p{2.2cm} % Noise Density
    >{\raggedright\arraybackslash}X}       % Balancing Method and Results
\toprule
\textbf{Institution} & \textbf{Actuators} & \textbf{Noise Density} & \textbf{Balancing Method and Results} \\
\midrule
Cal Poly San Luis Obispo~\cite{dam_applied_2014} & 
Reaction Wheels & 
\SI{0.0025}{\degree\per\second} & 
Batch Estimation \newline $<\SI{1.5}{\milli\metre}$ \\
\addlinespace[0.75em]

Georgia Tech~\cite{choi_automatic_2016} & 
Reaction Wheels & 
\SI{0.05}{\degree\per\second} & 
Underactuated Feedback Control \\
\addlinespace[0.75em]
Naval Postgraduate School~\cite{kim_system_2006} & 
Control Moment Gyros & 
\SI{0.007}{\degree\per\second} & 
Fully Actuated Feedback Control \newline $<\SI{0.327}{\newton\metre}$ \\
\addlinespace[0.75em]
University of BrasÃ­lia~\cite{silva_filtering_2018} & 
Reaction Wheels, Magnetorquers & 
\SI{0.05}{\degree\per\second} & 
Batch Estimation and Filtering \newline $<\num{3.5e-5}\,\si{\newton\metre}$ \\
\addlinespace[0.75em]
University of Bologna~\cite{modenini2020dynamic} & 
Reaction Wheels & 
\SI{0.004}{\degree\per\second} & 
Underactuated Feedback Control \newline $<\num{5e-5}\,\si{\newton\metre}$ \\
\addlinespace[0.75em]
University of Florida~\cite{saulnier2014six} & 
Thrusters & 
N/A & 
Manual Balancing \\
\addlinespace[0.75em]
Harbin Institute of Technology~\cite{xu_parameter_2015} & 
Reaction Wheels & 
\SI{0.04}{\degree\per\second} & 
Batch Estimation and Filtering \newline $<\SI{5}{\micro\metre}$ \\
\bottomrule
\end{tabularx}

\vspace{0.5em}
\raggedright\footnotesize
\textit{Note: Balancing results are included as reported. Results are either listed as the maximum torque due to gravity measured during testing or the estimated center of mass offset.}
\end{table}
